import PyPDF2
import openpyxl
import os
import re

def extract_information(pdf_path):
    with open(pdf_path, 'rb') as file:
        pdf_reader = PyPDF2.PdfReader(file)
        extracted_text = ''

        for pgnum in range(len(pdf_reader.pages)):
            pg = pdf_reader.pages[pgnum]
            extracted_text += pg.extract_text()

        serial_pattern = re.compile(r'Serial\s*:\s*(\S+)')
        mod_pattern = re.compile(r'Model\s*:\s*(\S+)')
        pcsn_pattern = re.compile(r'Serial\s*:\s*.*?Serial\s*:\s*(\S+)')
        stat_pattern = re.compile(r'Status\s*:\s*.*?Status\s*:\s*(\S+)')

        sn_match = serial_pattern.search(extracted_text)
        mod_match = mod_pattern.search(extracted_text)
        pcsn_match = pcsn_pattern.search(extracted_text)
        stat_match = stat_pattern.search(extracted_text)

        sn = sn_match.group(1) if sn_match else None
        mod = mod_match.group(1) if mod_match else None
        pcsn = pcsn_match.group(1) if pcsn_match else None
        stat = stat_match.group(1) if stat_match else None
    return sn, mod, pcsn, stat









 serial_pattern = re.compile(r'Serial\s*:\s*(\S+)')
        mod_pattern = re.compile(r'Model\s*:\s*(\S+)')
        pcsn_pattern = re.compile(r'Serial(?:[^S]*Serial(?:[^S]*Serial\s*(\S+))?')
        stat_pattern = re.compile(r'Status(?:[^S]*Status(?:[^S]*Status\s*(\S+))?')

        sn_match = serial_pattern.search(extracted_text)
        mod_match = mod_pattern.search(extracted_text)
        pcsn_match = pcsn_pattern.search(extracted_text)
        stat_match = stat_pattern.search(extracted_text)

        sn = sn_match.group(1) if sn_match else None
        mod = mod_match.group(1) if mod_match else None
        pcsn = pcsn_match.group(2) if pcsn_match else None
        stat = stat_match.group(2) if stat_match else None
    print(sn,mod,pcsn,stat)
    return sn, mod, pcsn, stat








import re

def extract_information(pdf_path):
    with open(pdf_path, 'rb') as file:
        pdf_reader = PyPDF2.PdfReader(file)
        extracted_text = ''

        for pgnum in range(len(pdf_reader.pages)):
            pg = pdf_reader.pages[pgnum]
            extracted_text += pg.extract_text()

        serial_pattern = re.compile(r'Serial\s*:\s*(\S+)', re.IGNORECASE)
        mod_pattern = re.compile(r'Model\s*:\s*(\S+)', re.IGNORECASE)
        pcsn_pattern = re.compile(r'Serial(?:[^S]*Serial\s*:\s*(\S+))?')
        stat_pattern = re.compile(r'Status(?:[^S]*Status\s*:\s*(\S+))?')

        sn_match = serial_pattern.search(extracted_text)
        mod_match = mod_pattern.search(extracted_text)
        pcsn_match = pcsn_pattern.search(extracted_text)
        stat_match = stat_pattern.search(extracted_text)

        sn = sn_match.group(1) if sn_match else None
        mod = mod_match.group(1) if mod_match else None
        pcsn = pcsn_match.group(1) if pcsn_match else None
        stat = stat_match.group(1) if stat_match else None

    print(sn, mod, pcsn, stat)
    return sn, mod, pcsn, stat






import re

def extract_information(pdf_path):
    with open(pdf_path, 'rb') as file:
        pdf_reader = PyPDF2.PdfReader(file)
        extracted_text = ''

        for pgnum in range(len(pdf_reader.pages)):
            pg = pdf_reader.pages[pgnum]
            extracted_text += pg.extract_text()

        serial_pattern = re.compile(r'Serial\s*:\s*(\S+)', re.IGNORECASE)
        mod_pattern = re.compile(r'Model\s*:\s*(\S+)', re.IGNORECASE)
        pcsn_pattern = re.compile(r'Serial\s*:\s*(\S+)(?:[^S]*Serial\s*:\s*(\S+))?')
        stat_pattern = re.compile(r'Status\s*:\s*(\S+)(?:[^S]*Status\s*:\s*(\S+))?')

        sn_match = serial_pattern.search(extracted_text)
        mod_match = mod_pattern.search(extracted_text)
        pcsn_match = pcsn_pattern.search(extracted_text)
        stat_match = stat_pattern.search(extracted_text)

        sn = sn_match.group(1) if sn_match else None
        mod = mod_match.group(1) if mod_match else None
        pcsn = pcsn_match.group(1) if pcsn_match else None
        stat = stat_match.group(1) if stat_match else None

    print(sn, mod, pcsn, stat)
    return sn, mod, pcsn, stat




serial_pattern = re.compile(r'Serial\s*:\s*(\S+)', re.IGNORECASE)
        mod_pattern = re.compile(r'Model\s*:\s*(\S+)', re.IGNORECASE)
        pcsn_pattern = re.compile(r'Serial\s*:\s*(\S+)(?:[^S]*Serial\s*:\s*(\S+))?')
        stat_pattern = re.compile(r'Status\s*:\s*(\S+)(?:[^S]*Status\s*:\s*(\S+))?')
        
        sn_match = serial_pattern.search(extracted_text)
        mod_match = mod_pattern.search(extracted_text)
        pcsn_match = pcsn_pattern.search(extracted_text)
        stat_match = stat_pattern.search(extracted_text)

        sn = sn_match.group(1) if sn_match else None
        mod = mod_match.group(1) if mod_match else None
        pcsn = pcsn_match.group(2) if pcsn_match else None
        stat = stat_match.group(2) if stat_match else None
    print(sn,mod,pcsn,stat)
    return sn, mod, pcsn, stat


#this is the output, and remember the code I wrote is
#print(sn, mod, pcsn, stat). sn is correct, mod is basically correct don't worry about that rn
#pcsn is the first Serial, not the second (you can tell because it is a duplicate of sn)
#stat is also using its first occurence of 'Status:' string
S41GNA0M403704 SAMSUNG S41GNA0M403704 good
S4ELNF2N116556 SAMSUNG S4ELNF2N116556 good

# the following is not the output
#it is the file being read from
#you can see in the following text that there are 2 occurrences of Status:, I want the second one
Serial
:
S4ELNF2N116556
Size
:
512.1	GB
Bus
:
NVMe
Sectors
:
1000233648	(512	byte	sector)
HPA:
Doesn't	Exist
DCO:
Doesn't	Exist
Remapped	Sectors
:
0
Health	Status
:
good
Remapped	Sectors	After	Erasure
:
0
Start/End	Time
:
2023-09-25	14:56:18+0000	
/	
2023-09-25	14:59:12+0000
Duration
:
00:00:02:54	(DD:HH:MM:SS)
Method
:
NIST	800-88	Clear	(NVMe	Sanitize	Crypto	Erase)
Verification	Method
:
Quick	Sampling
Erasure	Rounds
:
1	(1	
firmware
)
Status
:
Erased






import re

def extract_information(pdf_path):
    with open(pdf_path, 'rb') as file:
        pdf_reader = PyPDF2.PdfReader(file)
        extracted_text = ''

        for pgnum in range(len(pdf_reader.pages)):
            pg = pdf_reader.pages[pgnum]
            extracted_text += pg.extract_text()

        serial_pattern = re.compile(r'Serial\s*:\s*(\S+)', re.IGNORECASE)
        mod_pattern = re.compile(r'Model\s*:\s*(\S+)', re.IGNORECASE)
        pcsn_pattern = re.compile(r'Serial.*?\s*:\s*(\S+).*?Serial\s*:\s*(\S+)', re.IGNORECASE)
        stat_pattern = re.compile(r'Status.*?\s*:\s*(\S+).*?Status\s*:\s*(\S+)', re.IGNORECASE)

        sn_match = serial_pattern.search(extracted_text)
        mod_match = mod_pattern.search(extracted_text)
        pcsn_match = pcsn_pattern.search(extracted_text)
        stat_match = stat_pattern.search(extracted_text)

        sn = sn_match.group(1) if sn_match else None
        mod = mod_match.group(1) if mod_match else None
        pcsn = pcsn_match.group(2) if pcsn_match else None
        stat = stat_match.group(2) if stat_match else None

    print(sn, mod, pcsn, stat)
    return sn, mod, pcsn, stat







mod_pattern = re.compile(r'Model\s*:\s*([\s\S]+?)\b', re.IGNORECASE)

# ...

mod_match = mod_pattern.search(extracted_text)

if mod_match:
    model_line = file.readline().strip()
    model_info = mod_match.group(1)
    
    # Assuming the desired information is after the colon and space
    model = model_line.split(': ')[1]
    print(model)
else:
    print("Model information not found.")







Traceback (most recent call last):
  File "C:\Users\JPeake\OneDrive - HTG Inc\Desktop\pythonthings\s7.py", line 112, in <module>
    update_spreadsheet(pdf_file_path, spreadsheet_path, row_number)
  File "C:\Users\JPeake\OneDrive - HTG Inc\Desktop\pythonthings\s7.py", line 89, in update_spreadsheet
    wb = openpyxl.load_workbook(spreadsheet)
  File "C:\Users\JPeake\OneDrive - HTG Inc\Desktop\pythonthings\openpyxl\reader\excel.py", line 344, in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
  File "C:\Users\JPeake\OneDrive - HTG Inc\Desktop\pythonthings\openpyxl\reader\excel.py", line 123, in __init__
    self.archive = _validate_archive(fn)
  File "C:\Users\JPeake\OneDrive - HTG Inc\Desktop\pythonthings\openpyxl\reader\excel.py", line 95, in _validate_archive
    archive = ZipFile(filename, 'r')
  File "C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.11_3.11.1776.0_x64__qbz5n2kfra8p0\Lib\zipfile.py", line 1302, in __init__
    self._RealGetContents()
  File "C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.11_3.11.1776.0_x64__qbz5n2kfra8p0\Lib\zipfile.py", line 1369, in _RealGetContents
    raise BadZipFile("File is not a zip file")
zipfile.BadZipFile: File is not a zip file




for root, dirs, files in os.walk(pdf_file_path):
    for file in files:
        if file.endswith('.pdf):





Warning (from warnings module):
  File "C:\Users/JPeake/OneDrive - HTG Inc/Desktop/pythonthings\openpyxl\reader\workbook.py", line 84
    warn(msg)
UserWarning: File contains an invalid specification for 0. This will be removed
[]






Warning (from warnings module):
  File "C:\Users\JPeake\OneDrive - HTG Inc\Desktop\pythonthings\openpyxl\reader\workbook.py", line 84
    warn(msg)
UserWarning: File contains an invalid specification for 0. This will be removed
Traceback (most recent call last):
  File "C:\Users\JPeake\OneDrive - HTG Inc\Desktop\pythonthings\s8.py", line 94, in <module>
    update_spreadsheet(pdf_file_path, spreadsheet_path, row_number)     #4th if the files is a pdf, take it to the update spreadsheet function (I have had the idea that it should go to the extraction function first)
  File "C:\Users\JPeake\OneDrive - HTG Inc\Desktop\pythonthings\s8.py", line 72, in update_spreadsheet
    ws = wb['Sheet1']
  File "C:\Users\JPeake\OneDrive - HTG Inc\Desktop\pythonthings\openpyxl\workbook\workbook.py", line 287, in __getitem__
    raise KeyError("Worksheet {0} does not exist.".format(key))
KeyError: 'Worksheet Sheet1 does not exist.'
